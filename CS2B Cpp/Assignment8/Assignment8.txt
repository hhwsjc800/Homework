#include <iostream>
#include <ctime>
#include <string>
#include <list>

using namespace std;
// class Card prototype ----------------------------------------
class Card
{
public:
   enum Suit { clubs, diamonds, hearts, spades };
   static char DEFAULT_VAL;
   static Suit DEFAULT_SUIT;
   static const int NUM_CARD_VALS = 13;
   static const int NUM_CARD_SUITS = 4;
   const static char valueRanks[NUM_CARD_VALS]; 
   const static Suit suitRanks[NUM_CARD_SUITS];

   int compareTo(Card &other);
   static int getSuitRank(Suit st);
   static int getValueRank(char val);

private:
   char value;
   Suit suit;
   bool errorFlag;

public:
   Card(char value = DEFAULT_VAL, Suit suit = DEFAULT_SUIT);
   string toString();
   bool set(char value = DEFAULT_VAL, Suit suit = DEFAULT_SUIT);

   char getVal() { return value; }
   Suit getSuit() { return suit; }
   bool getErrorFlag() { return errorFlag; }
   bool equals(Card card);

   // helpers
private:
   bool isValid(char value, Suit suit);
};

char Card::DEFAULT_VAL = 'A';
Card::Suit Card::DEFAULT_SUIT = Card::spades;

// beginning of Card method definitions --------------------------
// constructor
Card::Card(char value, Suit suit)
{
   // because mutator sets errorFlag, we don't have to test
   set(value, suit);
}

// stringizer
string Card::toString()
{
   string retVal = " ";  // just enough space for the value char

   if (errorFlag)
      return "** illegal **";

   // convert char to a string
   retVal[0] = value;

   if (suit == spades)
      retVal += " of Spades";
   else if (suit == hearts)
      retVal += " of Hearts";
   else if (suit == diamonds)
      retVal += " of Diamonds";
   else if (suit == clubs)
      retVal += " of Clubs";

   return retVal;
}

// mutator
bool Card::set(char value, Suit suit)
{
   char upVal;

   // convert to uppercase to simplify (may need to #include <cctype>)
   upVal = toupper((int)value);

   if ( !isValid(upVal, suit))
   {
      errorFlag = true;
      return false;
   }

   // else implied
   errorFlag = false;
   this->value = upVal;
   this->suit = suit;
   return true;
}

// helper
bool Card::isValid(char value, Suit suit)
{
   string upVal = "_";  // string to hold the 1-char value
   string legalVals = "23456789TJQKA";

   // convert to uppercase to simplify
   upVal[0] = toupper((int)value);

   // check for validity
   if ( legalVals.find(upVal) != string::npos )
      return true;
   else
      return false;
}

bool Card::equals(Card card)
{
   if (this->value != card.value)
      return false;
   if (this->suit != card.suit)
      return false;
   if (this->errorFlag != card.errorFlag)
      return false;
   return true;
}

// Card comparison method definitions ----------------------------------
int Card::compareTo(Card &other)
{
   if (this->value == other.value)
      return ( getSuitRank(this->suit) - getSuitRank(other.suit) );
   // else
   return getValueRank(this->value) - getValueRank(other.value) ;
}

int Card::getSuitRank(Suit st)
{
   int k;

   for (k = 0; k < NUM_CARD_SUITS; k++) 
      if (suitRanks[k] == st)
         return k;

   // should not happen
   return 0;
}

int Card::getValueRank(char val)
{
   int k;

   for (k = 0; k < NUM_CARD_VALS; k++) 
      if (valueRanks[k] == val)
         return k;

   // should not happen
   return 0;
}


// end of Card method definitions ----------------------------------

// global scope method prototypes
typedef list<Card> CardList;
void showList(CardList &myList);
void insert(CardList &myList, Card &x);
bool remove(CardList &myList, Card &x);
bool removeAll(CardList &myList, Card &x);

// for easy comparisons
int operator==(Card first, Card other) 
   { return first.compareTo(other) == 0; }

// for client Card generation
Card generateRandomCard();

// for comparisons -- ordering values and ranks
const char Card::valueRanks[NUM_CARD_VALS]   // forces correct numInitializers
   = { '2', '3', '4', '5', '6', '7', '8', '9', 'T',
   'J', 'Q', 'K', 'A'};   
const Card::Suit Card::suitRanks[NUM_CARD_SUITS] = {Card::clubs, 
Card::diamonds, Card::hearts, Card::spades};

// main for program
int main()
{
   int k;
   const int numCards = 10;
   int firstCard = 0, lastCard = numCards - 1;
   CardList myList;
   Card cardArray[numCards];

   srand(time(NULL));  // or not, if you want repetition
   
   for (k = 0; k < numCards; k++)
   {
      cardArray[k] = generateRandomCard(); //instantiate rand card

      //double insert into card array
      insert(myList, cardArray[k]); 
      insert(myList, cardArray[k]);
   }

   cout << "***Initial List***";
   showList(myList);

   for (k = 0; k < numCards/2; k++)
   {
      while (remove(myList, cardArray[k]))
      {
         //loops until removes all copies of cardArray[k]
      }
   }

   cout << "***Roughly Half Cards Removed List***";
   showList(myList);

   if (removeAll(myList, cardArray[firstCard]))
      cout << "Removed all instances of " << cardArray[firstCard].toString() 
           << " in the list.\n";
   else
      cout << "Couldn't find " << cardArray[firstCard].toString() 
           << " in the list! (expected)\n";

   if (removeAll(myList, cardArray[lastCard]))
      cout << "Removed all instances of " << cardArray[lastCard].toString()
           << " in the list (expected) \n\n";
   else
      cout << "Failed to find " << cardArray[lastCard].toString() 
           << " in the list (happens rarely due to randomness)\n\n";

   cout << "***Final List***";
   showList(myList);

   int foo;
   cin >> foo;

   return 0;
}

// new global scope method -------------------------------------------
Card generateRandomCard()
{
   Card::Suit suit;
   char val;

   suit = (Card::Suit) ( rand() % Card::NUM_CARD_SUITS );
   val = Card::valueRanks[ rand() % Card::NUM_CARD_VALS ];

   return Card(val, suit);
}

void showList(CardList &myList)
{
   list<Card>::iterator iter;

   cout << endl << "_____List of Cards_______" << endl;
   for( iter = myList.begin(); iter != myList.end(); iter++)
   {
      cout << "(" << iter->toString() << ")  ";
   }
   cout << "\n_____End Card List_______" << endl << endl;

}

void insert(CardList &myList, Card &x)
{
   list<Card>::iterator iter;

   // loop until we find a card
   for (iter = myList.begin() ; iter != myList.end() ; iter++ )
      if ( x.compareTo(*iter) < 0)
         break;   // found the exact place for this float 
   myList.insert(iter, x);
}

bool remove(CardList &myList, Card &x)
{
   list<Card>::iterator iter;

   // loop until we find or exhaust list
   for (iter = myList.begin() ; iter != myList.end() ; iter++ )
      if ( x == *iter )
      {
         myList.erase(iter);
         return true;
      }
   return false;
}

bool removeAll(CardList &myList, Card &x)
{
   list<Card>::iterator iter;


   for (iter = myList.begin() ; iter != myList.end() ; iter++ )
   if ( x == *iter )
   {
      myList.remove(x);
      return true;
   }

   return false;
}

/****Run of Assignment 8*********************

***Initial List***
_____List of Cards_______
(3 of Spades)  (3 of Spades)  (8 of Clubs)  (8 of Clubs)  (8 of Clubs)  (8 of Cl
ubs)  (8 of Spades)  (8 of Spades)  (T of Clubs)  (T of Clubs)  (Q of Clubs)  (Q
 of Clubs)  (Q of Diamonds)  (Q of Diamonds)  (K of Spades)  (K of Spades)  (A o
f Clubs)  (A of Clubs)  (A of Clubs)  (A of Clubs)
_____End Card List_______

***Roughly Half Cards Removed List***
_____List of Cards_______
(8 of Spades)  (8 of Spades)  (T of Clubs)  (T of Clubs)  (Q of Diamonds)  (Q of
 Diamonds)  (K of Spades)  (K of Spades)
_____End Card List_______

Couldn't find 8 of Clubs in the list! (expected)
Removed all instances of K of Spades in the list (expected)

***Final List***
_____List of Cards_______
(8 of Spades)  (8 of Spades)  (T of Clubs)  (T of Clubs)  (Q of Diamonds)  (Q of
 Diamonds)
_____End Card List_______



**********************************/